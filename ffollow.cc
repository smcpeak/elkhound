// ffollow.cc
// *** DO NOT EDIT BY HAND ***
// automatically generated by gramanl, from ffollow.gr

// GLR source location information is enabled

#include "ffollow.h"     // Context
#include "parsetables.h" // ParseTables
#include "srcloc.h"      // SourceLoc

#include <assert.h>      // assert
#include "sm-iostream.h" // cout
#include <stdlib.h>      // abort

static char const *termNames[] = {
  "eof",  // 0
  "plus",  // 1
  "star",  // 2
  "lparen",  // 3
  "rparen",  // 4
  "id",  // 5
};

string Context::terminalDescription(int termId, SemanticValue sval)
{
  return stringc << termNames[termId]
                 << "(" << (sval % 100000) << ")";
}


static char const *nontermNames[] = {
  "empty",  // 0
  "__EarlyStartSymbol",  // 1
  "S",  // 2
  "E",  // 3
  "Ep",  // 4
  "T",  // 5
  "Tp",  // 6
  "F",  // 7
};

string Context::nonterminalDescription(int nontermId, SemanticValue sval)
{
  return stringc << nontermNames[nontermId]
                 << "(" << (sval % 100000) << ")";
}


char const *Context::terminalName(int termId)
{
  return termNames[termId];
}

char const *Context::nonterminalName(int nontermId)
{
  return nontermNames[nontermId];
}

// ------------------- actions ------------------
// [0] __EarlyStartSymbol[void] -> top:S $
inline void Context::action0___EarlyStartSymbol(SourceLoc loc, SemanticValue top)
#line 1 "<init>"
{ return;  }
#line 65 "ffollow.cc"

// [1] S[void] -> E
inline void Context::action1_S(SourceLoc loc)
{return; }
// [2] E[void] -> T Ep
inline void Context::action2_E(SourceLoc loc)
{return; }
// [3] Ep[void] -> + +
inline void Context::action3_Ep(SourceLoc loc)
{return; }
// [4] Ep[void] -> empty
inline void Context::action4_Ep(SourceLoc loc)
#line 14 "ffollow_ext.gr"
{ return 1;  }
#line 80 "ffollow.cc"

// [5] T[void] -> F Tp
inline void Context::action5_T(SourceLoc loc)
{return; }
// [6] Tp[void] -> * F Tp
inline void Context::action6_Tp(SourceLoc loc)
{return; }
// [7] Tp[void] -> empty
inline void Context::action7_Tp(SourceLoc loc)
{return; }
// [8] F[void] -> ( E )
inline void Context::action8_F(SourceLoc loc)
{return; }
// [9] F[void] -> id
inline void Context::action9_F(SourceLoc loc)
{return; }

/*static*/ SemanticValue Context::doReductionAction(
  Context *ths,
  int productionId, SemanticValue const *semanticValues,
  SourceLoc loc)
{
  switch (productionId) {
    case 0:
      return (SemanticValue)(ths->action0___EarlyStartSymbol(loc, (SemanticValue)(semanticValues[0])), 0);
    case 1:
      return (SemanticValue)(ths->action1_S(loc), 0);
    case 2:
      return (SemanticValue)(ths->action2_E(loc), 0);
    case 3:
      return (SemanticValue)(ths->action3_Ep(loc), 0);
    case 4:
      return (SemanticValue)(ths->action4_Ep(loc), 0);
    case 5:
      return (SemanticValue)(ths->action5_T(loc), 0);
    case 6:
      return (SemanticValue)(ths->action6_Tp(loc), 0);
    case 7:
      return (SemanticValue)(ths->action7_Tp(loc), 0);
    case 8:
      return (SemanticValue)(ths->action8_F(loc), 0);
    case 9:
      return (SemanticValue)(ths->action9_F(loc), 0);
    default:
      assert(!"invalid production code");
      return (SemanticValue)0;   // silence warning
  }
}

UserActions::ReductionActionFunc Context::getReductionAction()
{
  return (ReductionActionFunc)&Context::doReductionAction;
}


// ---------------- dup/del/merge/keep nonterminals ---------------

SemanticValue Context::duplicateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    case 1:
      return sval;
    case 2:
      return sval;
    case 3:
      return sval;
    case 4:
      return sval;
    case 5:
      return sval;
    case 6:
      return sval;
    case 7:
      return sval;
    default:
      return (SemanticValue)0;
  }
}

void Context::deallocateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    case 1:
      break;
    case 2:
      break;
    case 3:
      break;
    case 4:
      break;
    case 5:
      break;
    case 6:
      break;
    case 7:
      break;
    default:
      cout << "WARNING: there is no action to deallocate nonterm "
           << nontermNames[nontermId] << endl;
  }
}

SemanticValue Context::mergeAlternativeParses(int nontermId, SemanticValue left,
                                           SemanticValue right,  SourceLoc loc)
{
  switch (nontermId) {
    default:
      cout << toString(loc)
           << ": WARNING: there is no action to merge nonterm "
           << nontermNames[nontermId] << endl;
      return left;
  }
}

bool Context::keepNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    default:
      return true;
  }
}


// ---------------- dup/del/classify terminals ---------------
SemanticValue Context::duplicateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      return sval;
    case 1:
      return sval;
    case 2:
      return sval;
    case 3:
      return sval;
    case 4:
      return sval;
    case 5:
      return sval;
    default:
      return (SemanticValue)0;
  }
}

void Context::deallocateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      break;
    case 1:
      break;
    case 2:
      break;
    case 3:
      break;
    case 4:
      break;
    case 5:
      break;
    default:
      cout << "WARNING: there is no action to deallocate terminal "
           << termNames[termId] << endl;
  }
}

/*static*/ int Context::reclassifyToken(Context *ths, int oldTokenType, SemanticValue sval)
{
  switch (oldTokenType) {
    default:
      return oldTokenType;
  }
}

UserActions::ReclassifyFunc Context::getReclassifier()
{
  return (ReclassifyFunc)&Context::reclassifyToken;
}


// this makes a ParseTables from some literal data;
// the code is written by ParseTables::emitConstructionCode()
// in parsetables.cc
class Context_ParseTables : public ParseTables {
public:
  Context_ParseTables();
};

Context_ParseTables::Context_ParseTables()
  : ParseTables(false /*owning*/)
{
  numTerms = 6;
  numNonterms = 8;
  numStates = 17;
  numProds = 10;
  actionCols = 6;
  actionRows = 17;
  gotoCols = 8;
  gotoRows = 17;
  ambigTableSize = 0;
  startState = (StateId)0;
  finalProductionIndex = 0;
  bigProductionListSize = 0;
  errorBitsRowSize = 4;
  uniqueErrorRows = 0;

  // storage size: 204 bytes
  // rows: 17  cols: 6
  static ActionEntry const actionTable_static[102] = {
    /* 0*/ 0, 0, 0, 6, 0, 8,
    /* 1*/ 0, 0, 0, 0, 0, 0,
    /* 2*/ 0, 4, 0, 0, 0, 0,
    /* 3*/ -4, 0, 0, 0, -4, 0,
    /* 4*/ 0, 0, 0, 6, 0, 8,
    /* 5*/ 0, 0, 0, 6, 0, 8,
    /* 6*/ -9, -9, -9, 0, -9, 0,
    /* 7*/ -10, -10, -10, 0, -10, 0,
    /* 8*/ 2, 0, 0, 0, 0, 0,
    /* 9*/ 0, 0, 0, 0, 7, 0,
    /*10*/ -2, 0, 0, 0, 0, 0,
    /*11*/ -3, 0, 0, 0, -3, 0,
    /*12*/ -5, 3, 0, 0, -5, 0,
    /*13*/ -6, -6, 0, 0, -6, 0,
    /*14*/ -7, -7, 0, 0, -7, 0,
    /*15*/ -8, -8, 5, 0, -8, 0,
    /*16*/ -8, -8, 5, 0, -8, 0,
  };
  actionTable = const_cast<ActionEntry*>(actionTable_static);

  // storage size: 272 bytes
  // rows: 17  cols: 8
  static GotoEntry const gotoTable_static[136] = {
    /* 0*/ 65535, 65535, 8, 10, 65535, 12, 65535, 15,
    /* 1*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 2*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 3*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 4*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 16,
    /* 5*/ 65535, 65535, 65535, 9, 65535, 12, 65535, 15,
    /* 6*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 7*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 8*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /* 9*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /*10*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /*11*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /*12*/ 65535, 65535, 65535, 65535, 11, 65535, 65535, 65535,
    /*13*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /*14*/ 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    /*15*/ 65535, 65535, 65535, 65535, 65535, 65535, 13, 65535,
    /*16*/ 65535, 65535, 65535, 65535, 65535, 65535, 14, 65535,
  };
  gotoTable = const_cast<GotoEntry*>(gotoTable_static);

  static ParseTables::ProdInfo const prodInfo_static[10] = {
    /*0*/ {2,1}, {1,2}, {2,3}, {2,4}, {0,4}, {2,5}, {3,6}, {0,6}, {3,7}, {1,7},
  };
  prodInfo = const_cast<ParseTables::ProdInfo*>(prodInfo_static);

  static SymbolId const stateSymbol_static[17] = {
    /*0*/ 0, 1, 2, 2, 3, 4, 5, 6, -3, -4, -4, -5, -6, -7, -7, -8,
    /*1*/ -8,
  };
  stateSymbol = const_cast<SymbolId*>(stateSymbol_static);

  ActionEntry *ambigTable_static = NULL;
  ambigTable = const_cast<ActionEntry*>(ambigTable_static);

  static NtIndex const nontermOrder_static[8] = {
    /*0*/ 5, 4, 3, 2, 7, 1, 6, 0,
  };
  nontermOrder = const_cast<NtIndex*>(nontermOrder_static);

  ErrorBitsEntry *errorBits_static = NULL;
  errorBits = const_cast<ErrorBitsEntry*>(errorBits_static);

  errorBitsPointers = NULL;

  TermIndex *actionIndexMap_static = NULL;
  actionIndexMap = const_cast<TermIndex*>(actionIndexMap_static);

  actionRowPointers = NULL;

  NtIndex *gotoIndexMap_static = NULL;
  gotoIndexMap = const_cast<NtIndex*>(gotoIndexMap_static);

  gotoRowPointers = NULL;

  firstWithTerminal = NULL;
  firstWithNonterminal = NULL;
  bigProductionList = NULL;
  productionsForState = NULL;
  ambigStateTable = NULL;
}


ParseTables *Context::makeTables()
{
  return new Context_ParseTables;
}

